{
  "version": 3,
  "file": "Tester-unit.js",
  "sourceRoot": "../../src/test",
  "sources": [
    "Tester-unit.coffee"
  ],
  "names": [],
  "mappings": "AACA,IAAA,IAAA,EAAA,GAAA,EAAA;;AAAA,OAAA;EAAS,IAAT;EAAe,MAAf;CAAA,MAAA,cAAA;;;;;;;;;;;;;;AAcA,IAAA,GAAO,QAAA,CAAA,CAAA;SACL;AADK;;AAGP,GAAA,GAAO,QAAA,CAAE,CAAF,EAAK,CAAL,CAAA;SACL,CAAA,GAAI;AADC;;AAGP,IAAA,CAAO,YAAP,EAAqB,QAAA,CAAC,CAAD,CAAA;SACnB,CAAC,CAAC,EAAF,CAAM,IAAA,CAAA,CAAN,EAAc,CAAd;AADmB,CAArB;;AAGA,IAAA,CAAO,cAAP,EAAuB,QAAA,CAAC,CAAD,CAAA;SACrB,CAAC,CAAC,EAAF,CAAM,GAAA,CAAI,CAAJ,EAAM,CAAN,CAAN,EAAgB,CAAhB;AADqB,CAAvB;;AAGA,IAAA,CAAO,WAAP,EAAoB,QAAA,CAAC,CAAD,CAAA;SAClB,CAAC,CAAC,EAAF,CAAM,MAAM,CAAC,IAAP,CAAY,GAAZ,CAAN,EAAwB,QAAxB;AADkB,CAApB;;AAGA,IAAA,CAAO,aAAP,EAAsB,QAAA,CAAC,CAAD,CAAA;SACpB,CAAC,CAAC,EAAF,CAAM,MAAM,CAAC,IAAP,CAAY,KAAZ,CAAN,EAA0B,QAA1B;AADoB,CAAtB;;AAGM,OAAN,MAAA,KAAA;EACU,OAAP,IAAO,CAAA,CAAA,EAAA;;AADV;;AAGA,IAAA,CAAA,CAAM,CAAC,MAAP,CAAe,QAAf,EAAyB,mBAAzB,EAA8C,IAA9C;;AAEA,IAAA,CAAA,CAAM,CAAC,QAAP,CAAiB,QAAjB,EAA2B,6CAA3B,EAA0E,IAA1E;;AACA,IAAA,CAAO,+DAAP,EAAwE,QAAA,CAAC,CAAD,CAAA;AACxE,MAAA;EAAE,KAAA,GAAQ,CAAI,CAAE,CAAC,CAAC,OAAF,IAAc,CAAC,CAAC,QAAhB,IAA6B,CAAC,CAAC,QAAjC;SACZ,CAAC,CAAC,EAAF,CAAM,KAAN,EAAa,KAAb;AAFsE,CAAxE;;AAGA,IAAA,CAAO,8DAAP,EAAuE,QAAA,CAAC,CAAD,CAAA;AACvE,MAAA;EAAE,KAAA,GAAQ,CAAI,CAAE,CAAC,CAAC,OAAF,IAAc,CAAC,CAAC,QAAhB,IAA6B,CAAC,CAAC,QAAjC;SACZ,CAAC,CAAC,EAAF,CAAM,KAAN,EAAa,KAAb;AAFqE,CAAvE;;AAGA,IAAA,CAAA,CAAM,CAAC,GAAP,CAAY,IAAA,CAAA,CAAM,CAAC,OAAP,CAAA,CAAZ,EA5CA;;;AA+CA,IAAA,CAAA,CAAM,CAAC,QAAP,CAAiB,MAAjB,EAAyB,8CAAzB,EAAyE,IAAzE;;AACA,IAAA,CAAM,qBAAN,EAA8B,QAAA,CAAC,CAAD,CAAA;SAAO,CAAC,CAAC,EAAF,CAAO;IAAC,CAAA,EAAE;EAAH,CAAP,EAAgB;IAAC,CAAA,EAAE;EAAH,CAAhB;AAAP,CAA9B,EAhDA;;;;AAmDA,IAAA,CAAM,sBAAN,EAA8B,QAAA,CAAC,CAAD,CAAA;SAAO,CAAC,CAAC,EAAF,CAAK,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAL,EAAa,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,CAAb;AAAP,CAA9B,EAnDA;;;;AAsDA,IAAA,CAAA,CAAM,CAAC,GAAP,CAAY,IAAA,CAAA,CAAM,CAAC,OAAP,CAAA,CAAZ;;AAtDA",
  "sourcesContent": [
    "\nimport { test, tester } from './Tester.js'     # Only importing tester to unit test it\n\n# In this context all unit tests are executed immediately when this module is either\n#   dynaically  imported i.e module = import(path) - recommended\n# or statically imported i.e inport module from path\n\n# runUnitTestModulesFromPaths:( paths ) will dynamically import this module\n#   with paths = [\"/lib/pub/test/Tester-unitester.js\"]\n# For glob file patterns running in ViteJS there is\n# runUnitTestModulesWithViteJS:() will dynamically import this module\n#   using a glob pattern like \"/src/**/*-unitester.js\"  or \"/pub/**/*-unitester.js\"\n\n# t = tester\n\nfive = () ->\n  5\n\nadd  = ( a, b ) ->\n  a + b\n\ntest(  \"five() = 5\", (t) ->\n  t.eq( five(), 5 ) )\n\ntest(  \"add(2,3) = 5\", (t) ->\n  t.eq( add(2,3), 5 ) )\n\ntest(  \"type(123)\", (t) ->\n  t.eq( tester.type(123), 'number' ) )\n\ntest(  \"type('123')\", (t) ->\n  t.eq( tester.type('123'), 'string' ) )\n\nclass Main\n  @init = () =>\n\ntest().module( \"Tester\", \"Tester Unit tests\", true )\n\ntest().describe( \"test()\", \"Internal logic for turning tests on and off\", true )\ntest(  'not (  @testing and  @moduleOn and  @methodOn ) @method=false', (t) ->\n  isOff = not ( t.testing and t.moduleOn and t.methodOn )\n  t.eq( isOff, false ) )\ntest(  'not (  @testing and  @moduleOn and  @methodOn ) @method=true', (t) ->\n  isOff = not ( t.testing and t.moduleOn and t.methodOn )\n  t.eq( isOff, false ) )\ntest().log( test().summary() )\n#est( \"test() method count is 3\", tester.count(\"method\") , 3 ).log( test().status() )\n\ntest().describe( \"eq()\", \"eq() assertion inside test( text, (t) -> ...\", true )\ntest( 'eq({a:\"a\"},{a:\"a\"})',  (t) -> t.eq(  {a:\"a\"}, {a:\"a\"} ) )\n#est( 'eq({a:\"a\"},{a:\"b\"})',  (t) -> t.eq(  {a:\"a\"}, {a:\"b\"} ) )  # Noed ne\n#est( 'eq({a:\"a\"},{b:\"a\"})',  (t) -> t.eq(  {a:\"a\"}, {b:\"a\"} ) )  # Noed ne\ntest( \"eq([1,2,3],[1,2,3] )\", (t) -> t.eq([1,2,3],[1,2,3]    ) )\n#est( \"eq([1,2,3])\",          (t) -> t.eq([1,2,3],[1,2,3,4]  ) )  # Noed ne\n#est( 'eq((x)->,(y)->))',     (t) -> t.eq( (x)->, (y)->      ) )  # Need better handling of function types?\ntest().log( test().summary() )\n\n###\n  constructor:()\n  setOptions:( options )\n  test:( text, closure )\n  unit:( text, result, expect )\n  fits:( text, result, schema )\n  eq:( result, expect )\n  run:( text, result, expect, op )\n  describe:( description, suite=null )\n  initStatus:( result, expect, op )\n  assert:( result, expect, status, op, level=0, key=null, index=null )\n  examine:( pass, result, expect, status, op, info, key, index )\n  isSchema:( v )\n  toSchema:( expect,   op )\n  parseSchema:( expect, schema )\n  toRanges:( splits )\n  checkValuesTypes:( result, expect, status, op, key, index )\n  valuesEq:( result, expect, status, op )\n  unknownsEq:( result, expect, status )\n  textValue:( name, argue, key, index )\n  objectsEq:( result, expect, status, op, level )\n  arraysEq:( result, expect, status, op, level )\n  report:( result, expect, op, status )\n  status:()\n  block:()\n  runUnitTests:( paths )\n  path:( path )\n  summary:( module=null )\n  injectStream:( stream )\n  archiveLocal:( failed, passed )\n  reviewsLocal:( reviewFailed, reviewPassed )\n  isRange:(r)\n  toRange:(arg)\n  inRange:(arg,range)   \n###\n\n\n\n\n\n\n\n\n\n"
  ]
}