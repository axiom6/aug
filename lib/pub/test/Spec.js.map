{
  "version": 3,
  "file": "Spec.js",
  "sourceRoot": "../../src/test",
  "sources": [
    "Spec.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\nimport Type from \"./Type.js\"\n\nclass Spec extends Type\n\n  constructor:() ->\n    super()\n\n  isEnums:( arg, oper, type ) ->\n    oper is \"enums\" and @isArray(arg,type) and @isResultType(type)\n\n  # Check if an arg like expect is a 'spec'\n  verifySpec:( arg ) ->\n    @conditions( @isObject(arg), @isResultType(arg.type), @isSpec(arg.expect,arg.oper), @isCard(arg.card) )\n\n  isResultType:( type ) ->\n    pass = @isDef(type) and @isIn( type,    \"results\" )\n    @isWarn( pass, \"Not a Result\", type, Type.results, (t) -> t.log( t.warn() ) )\n\n  isExpectType:( type ) ->\n    pass = @isDef(type) and @isIn( type, \"expects\"      )\n    @isWarn( pass, \"Not a Expect\", type, Spec.expects, (t) -> t.log( t.warn() ) )\n\n  isOper:( oper ) ->\n    pass = @isDef(oper) and  @isIn( oper, \"opers\" )\n    @isWarn( pass, \"Not an 'oper'\", oper, \"opers\", (t) -> t.log( t.warn() ) )\n\n  isCard:( card ) ->\n    pass = @isDef(card) and @isIn( card, \"cards\" )\n    @isWarn( pass, \"Not a 'card'\", card, Spec.cards, (t) -> t.log( t.warn() ) )\n\n  # This approach insures that all conditions are checked and messages sent\n  #   then all arg returns are anded together to determine a final pass or fail\n  conditions:( args... ) ->\n    pass = true\n    pass = pass and arg for arg in args\n    pass\n\n  isSpec:( expect ) ->\n    type    = @type(expect)\n    isParse = @isSpecParse(  expect, type )\n    isObj   = @isSpecObject( expect, type )\n    console.log( \"isSpec(expect)\", { expect:expect, type:type, isParse:isParse, isObj:isObj }) if @debug\n    isParse or isObj\n\n  # In the first t\n  toSpec:( expect ) ->\n    type   = @type(expect)\n    spec = { type:\"any\", oper:\"any\", expect:\"any\", card:\"1\", spec:\"\"  }\n    spec = switch\n      when @isSpecParse(  expect, type ) then @toSpecParse(  spec, expect )\n      when @isSpecObject( expect, type ) then @toSpecObject( spec, expect )\n      else @toWarn( \"toSpec(expect)\", \"expect not spec 'string' or 'object'\"\n      , expect, type, \"spec\", spec, (t) -> t.log( t.warn() ) )\n\n  isSpecParse:  ( arg, type ) ->\n    type is \"string\" and arg.includes(\":\")\n\n  # toSpecParse:( spec, arg )\n  # Examples\n  #   \"array:[0,255]\" }      { type:\"array\",   oper:\"range\", check:[0,255],         card=\"1\" }\n  #   \"string:James\"         { type:\"string\",  oper:\"eq\",    check:James,           card=\"1\" }\n  #   \"string:a|b|c\"         { type:\"string\",  oper:\"enums\", check:\"a|b|c\",         card=\"1\" }\n  #   \"int:[0,100]\"          { type:\"int\",     oper:\"range\", check:[0,100],         card=\"1\" }\n  #   \"float:[0.0,100.0,1.0] { type:\"float\",   oper:\"range\", check:[0.0,100.0,1.0], card=\"1\" }\n  #   \"string:[\"\",\"zzz\"]     { type:\"string\",  oper:\"range\", check:[\"\",\"zzz\"],      card=\"1\" }\n  #   \"boolean\"              { type:\"boolean\", oper:\"any\",   check:\"any\",           card=\"1\" }\n  #   \"object:{r:[0,255],g:[0,255],b:[0,255]}\n  #     { type:\"object\", oper:\"range\", range:{r:[0,255],g:[0,255],b:[0,255]}, card=\"1\" }\n  #  \"array:[[0,360],[0,100],[0,100]]:?\"\n  #     { type:\"array\",  oper:\"range\", range:[[0,360],[0,100],[0,100]], card=\"?\" }\n  toSpecParse:( spec, arg ) ->\n    splits = arg.split(\":\")\n    length = splits.length\n    if length >= 1                                        # type\n      spec.type = splits[0]\n    if length >= 1                                        # expect\n      spec.spec = splits[1]\n      if splits[1].includes(\"|\")                         #   enum\n        spec.oper   = \"enums\"\n        spec.expect = @toEnums( splits[1] )\n      else if @isStrEnclosed( \"[\", splits[1], \"]\" )  #    range array\n        spec.oper   = \"range\"\n        spec.expect = @toArray( splits[1] )\n    else if @isStrEnclosed( \"{\", splits[1], \"}\" )   #    range object\n      spec.oper   = \"range\"\n      spec.expect = @toObject( splits[1] )\n    else\n      spec.oper   = \"any\"\n      spec.expect = \"any\"\n    if length >= 2                                        # card i.e cardinaliry\n      spec.oper = splits[2]\n    spec\n\n  isSpecObject: ( arg, type ) ->\n    type is \"object\" and arg.oper? and arg.expect? # and arg.type? and arg.card?\n\n  toSpecObject:( spec, arg ) ->\n    spec.type   = if arg.type?   then arg.type  else \"any\"\n    spec.oper   = if arg.oper?   then arg.oper  else \"any\"\n    spec.expect = if arg.expect? then arg.expect else \"any\"\n    spec.card   = if arg.card?   then arg.card  else  \"1\"  # required\n    spec.spec   = if arg.spec?   then arg.spec  else  \"\"   # required\n    spec\n\n  isSpecValue:  ( type )  ->\n    @isIn( type, \"results\" )\n\n  # Holding off on this conversion. Instead we will just return an expect value\n  toSpecValue:( spec, arg, type ) ->\n    spec.type   = type\n    spec.oper   = \"eq\"\n    spec.expect = arg\n    spec.card   = \"1\"  # required\n    spec.spec   = \"\"\n    spec\n\n\n  # Camnot is @arraysEq(...) because a single ramge can be applied to all resuls in a result array\n  inArrayRange:( result, range ) ->\n    pass    = true\n    type    = @type(result)\n    nResult = result.length\n    nRange  = range.length\n    if nRange  is 1\n      for i in [0...nResult] when @isArray(result[i])\n        pass = pass and @inMyRange( result[i], range )\n    else if nResult > nRange\n      text = \"not enough range tests #{nRange} for result so only will be #{nRange} tests on result\"\n      pass = @toWarn( \"inRange()\", text, result, type, false, (t) -> t.log( t.warn() ) )\n    else if nResult < nRange\n      text = \"OK with more range bounds #{nRange} than needed for result #{nResult}\"\n      pass = @toWarn( \"inRange()\", result, text, type, true, (t) -> t.log( t.warn() ) )\n      min = Math.min( nResult, nRange )\n      for i in [0...min] when @isArray(result[i]) and @isArray(range[i])\n        pass = pass and @inMyRange( result[i], range[i] )\n    pass\n\n  toEnums:( arg ) ->\n    enums = []\n    type  = type = @type(arg)\n    switch type\n      when \"string\" and arg.includes(\"|\")\n        splits = arg.split(\"|\")\n        for split in splits\n          enums.push( split )\n      when \"array\"\n        enums = arg\n      else\n        enums = @toWarn( \"toEnums(arg)\", \"unable to convert\", arg, \"enums\", [], (t) -> t.log( t.warn() ) )\n    enums\n\n  rangeType:( range ) ->\n    type = if range.length > 0 then @type(range[0]) else \"null\"\n    if @isIn( type, \"ranges\" )\n      if @isArray(range,type) then type else \"mixed\"\n    else if type is \"array\"\n      @rangeType(range[0])\n\n  # -- Range Methods --\n\n  # Asserts range with for types \"string\" or \"int\" or \"float\"\n  isRange:(range)  ->\n\n    # internal functions called after @rangeType(range) has verified that range\n    #   is an array of type \"string\" or \"int\" or \"float\"\n    isStrRamge = (r) -> r.length is 2 and r[0]      <= r[1]       # For 'string'\n    isIntRange    = (r) -> r.length is 2 and r[0]      <= r[1]       # For 'int'\n    isFloatRange  = (r) -> r.length is 3 and r[0]-r[2] <= r[1]+r[2]  # For 'float' r[2] is tol\n    isArrayRange  = (r) ->\n      pass = true\n      for e in r\n        pass = pass and @isRange(e)\n      pass\n\n    # @rangeType(...) checks array existence and asserts type with @isArray(range,type)\n    type = @rangeType(range)\n\n    switch type\n      when 'string' then isStrRamge(range)\n      when 'int'    then isIntRange(range)\n      when 'float'  then isFloatRange(range)\n      when 'array'  then isArrayRange(range)\n      else  @toWarn( \"isRange(range)\", \"not a range type\", range, \"\", false, (t) -> t.log( t.warn() ) )\n\n  # Override type.isIn() with addional Tester type arrays\n  isIn:( type, key ) ->\n    if      Type[key]? then Type[key].includes(type)     # Only reason for importing Type\n    else if Spec[key]? then Spec[key].includes(type)\n    else @isWarn( false, \"key #{key} missing for\", type, [], (t) -> t.log( t.warn() ) )\n\nSpec.specs   = [\"range\",\"enums\"]               # high level spec   based comparision specs\nSpec.opers   = [\"eq\",\"le\",\"lt\",\"ge\",\"gt\",\"ne\"] # low  level value  based comparison  ooers 'eq' default\nSpec.cards   = [\"n\",\"?\",\"*\",\"+\",\"min to max\"]  # cards  1 required, ? optional, * 0 to many, + 1 to many, m:m range\n\nexport spec = new Spec() # Export a singleton instence of type\nexport default Spec"
  ]
}