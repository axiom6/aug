{
  "version": 3,
  "file": "Spec.js",
  "sourceRoot": "../../src/test",
  "sources": [
    "Spec.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\nimport Type from \"./Type.js\"\n\nclass Spec extends Type\n\n  constructor:() ->\n    super()\n\n  # -- is... Spec assertions\n\n  isSpec:( arg ) ->\n    type = @type(arg)\n    switch type\n      when \"string\"\n        @isSpecParse(  arg )\n      when \"object\"\n         if @isSpecObject( arg )\n           true\n         else\n           pass = true\n           pass = pass and @isSpec(val) for own key, val of arg\n           pass\n      when \"array\"\n        pass = true\n        pass = pass and @isSpec(val)  for val in arg\n        pass\n      else\n        false\n\n  isSpecParse:(   arg ) ->\n    type = @type( arg )\n    @isDef(arg) and type isnt(\"object\") and ( type is \"regexp\" or ( type is \"string\" and arg.includes(\":\") ) )\n\n  isSpecObject: ( arg ) ->\n    @conditions( @isObject(arg), @isIn(arg.type,\"results\"), @isMatch(arg.match), @isCard(arg.card) )\n\n  isMatch:( match ) ->\n    switch\n      when @isRegexp(match) then true\n      when  @isEnums(match) then true\n      when  @isRange(match) then true\n      else  false\n\n\n  # let re = /ab+c/i; // literal notation\n  # let re = new RegExp('ab+c', 'i') // constructor with string pattern as first argument\n  # let re = new RegExp(/ab+c/, 'i') // constructor with regular express\n  isRegexp:( arg  ) ->\n    @isType(arg,\"regexp\")\n\n  # Asserts range with for types \"string\" or \"int\" or \"float\"\n  # internal functions verify an array of type \"string\" or \"int\" or \"float\"\n  #   is an array of type \"string\" or \"int\" or \"float\"\n  isRange:(range)  ->\n    return false if not @isArray(range)\n    isStrRange    = (r) -> r.length is 2 and r[0]      <= r[1]       # For 'string'\n    isIntRange    = (r) -> r.length is 2 and r[0]      <= r[1]       # For 'int'\n    isFloatRange  = (r) -> r.length is 3 and r[0]-r[2] <= r[1]+r[2]  # For 'float' r[2] is tol\n    switch @type(range[0])\n      when 'string' then isStrRange(range)\n      when 'int'    then isIntRange(range)\n      when 'float'  then isFloatRange(range)\n      else               false\n\n  # Moved to Type.coffee\n  isEnums:( arg ) ->\n    super.isEnums(arg)\n\n  isResult:( result ) ->\n    type =  @type(result)\n    @isDef(result) and @isIn( type, \"results\" )\n\n  isExpect:( expect ) ->\n    type =  @type(expect)\n    @isDef(expect) and @isIn( type, \"expects\" )\n\n  # This approach insures that all conditions are checked and messages sent\n  #   then all arg returns are anded together to determine a final pass or fail\n  conditions:( args... ) ->\n    pass = true\n    pass = pass and arg for arg in args\n    pass\n\n  # -- to... Spec conversions\n\n  toSpec:( arg ) ->\n    switch\n      when @isSpecParse(  arg )\n           @toSpecParse(  arg )\n      when @isSpecObject( arg )\n           @toSpecObject( arg )\n      when      @isArray( arg )\n        array = []\n        array.push(@toSpec(val)) for val in arg\n        array\n      when     @isObject( arg )\n        obj = {}\n        obj[key] = @toSpec(val) for own key, val of arg\n        obj\n      else @specInit()  # @specInit() creates a do nothing spec\n\n  # toSpecParse:( spec, arg )\n  # Examples\n  #   \"array:[0,255]\" }      { type:\"array\",   oper:\"range\", match:[0,255],         card=\"1\" }\n  #   \"string:James\"         { type:\"string\",  oper:\"eq\",    match:James,           card=\"1\" }\n  #   \"string:a|b|c\"         { type:\"string\",  oper:\"enums\", match:\"a|b|c\",         card=\"1\" }\n  #   \"int:[0,100]\"          { type:\"int\",     oper:\"range\", match:[0,100],         card=\"1\" }\n  #   \"float:[0.0,100.0,1.0] { type:\"float\",   oper:\"range\", match:[0.0,100.0,1.0], card=\"1\" }\n  #   \"string:[\"\",\"zzz\"]     { type:\"string\",  oper:\"range\", match:[\"\",\"zzz\"],      card=\"1\" }\n  #   \"boolean\"              { type:\"boolean\", oper:\"any\",   match:\"any\",           card=\"1\" }\n  #   \"object:{r:[0,255],g:[0,255],b:[0,255]}\n  #     { type:\"object\", oper:\"range\", match:{r:[0,255],g:[0,255],b:[0,255]}, card=\"1\" }\n  #  \"array:[[0,360],[0,100],[0,100]]:?\"\n  #     { type:\"array\",  oper:\"range\", match:[[0,360],[0,100],[0,100]], card=\"?\" }\n  toSpecParse:( arg ) ->\n    spec   = @toInit()\n    splits = arg.split(\":\")\n    length = splits.length\n    if length >= 1  then spec.type = splits[0]  # type\n    if length >= 1                              # match\n      type = @type(splits[1])\n      spec.match = switch type\n        when \"regexp\"  then  \"regexp\"           # regex\n        when \"string\"\n          switch\n            when splits[1].includes(\"|\")                then @toEnums(  splits[1] )  # enums\n            when @isStrEnclosed( \"[\", splits[1], \"]\" )  then @toArray(  splits[1] )  # range\n            when @isStrEnclosed( \"{\", splits[1], \"}\" )  then @toObject( splits[1] )  # object?\n            else  \"any\"\n        else \"any\"\n    if length >= 2 then spec.card = splits[2]  # card i.e cardinaliry\n    spec\n\n  toSpecObject:( arg ) ->\n    spec       = @specInit()\n    spec.type  = if arg.type?  then arg.type  else \"any\"\n    spec.match = if arg.match? then arg.match else \"any\"\n    spec.card  = if arg.card?  then arg.card  else  \"1\"  # required\n    spec\n\n  specInit:() ->\n    { type:\"any\", match:\"any\", card:\"1\" }\n\n  toRange:( arg ) ->\n    switch @type(arg)\n      when \"array\"  then arg\n      when \"string\" then @toArray(arg)\n      else \"any\"\n\n  # Moved to Type.coffee\n  toEnums:( arg ) ->\n    super.toEnums(arg)\n\n  # Arg types must be 'regexp' or 'string', otherwise returns 'any'\n  toRegexp:( arg ) ->\n    switch @type(arg)\n      when \"regexp\" then arg\n      when \"string\" then new RegExp(arg)\n      else \"any\"\n\n# -- in... Spec matches\n\n  inSpec:( result, spec ) =>\n    return false if not ( @isSpec(spec) and @type(result) is spec.type and @inCard(spec.card) )\n    match = spec.match\n    switch\n      when  @isArray(result) and  @isArray(spec) then  @inSpecArray( result, spec  )\n      when @isObject(result) and @isObject(spec) then @inSpecObject( result, spec  )\n      when @isRange(  match )                    then @isRange(      result, match )\n      when @isEnums(  match )                    then @isEnums(      result, match )\n      when @isRegexp( match )                    then @isRegexp(     result, match )\n      else false\n\n  # Here only minimum length of spec and result are checked\n  inSpecArray:( result, spec ) ->\n    pass = true\n    min  = Math.min( result.length, spec.length )\n    pass = pass and @inSpec(result[i],spec[i]) for i in [0...min]\n    pass\n\n  # Here only the keys common to both spec and result are checked\n  inSpecObject:( result, spec ) ->\n    pass = true\n    for own key, val of spec when result[key]         # Only travese the keys the\n      pass = pass and @inSpec(result[key],spec[key])\n    pass\n\n  # Determine if a result is bounded witnin a range.\n  # This method is here in Tester because it call @examine()\n  inRange:( result, range ) ->\n    return false if not  @isRange(range)\n    range = @toRange(range) # Convers the 'string' represention of range if necessary\n    inStrRange   = ( string, range ) -> range[0]          <= string and string <= range[1]\n    inIntRange   = ( int,    range ) -> range[0]          <= int    and int    <= range[1]\n    inFloatRange = ( float,  range ) -> range[0]-range[2] <= float  and float  <= range[1]+range[2]\n    switch @type(result)\n      when \"string\" then inStrRange(     result, range )\n      when \"int\"    then inIntRange(     result, range )\n      when \"float\"  then inFloatRange(   result, range )\n      else false\n\n  # Determine if a result is enumerated.\n  inEnums:( result, enums ) ->\n    return false if not @isEnums(enums)\n    enums = @toEnums( enums )  # Convers the 'string' represention of enums if necessary\n    @inArray( result, enums )\n\n  inRegexp:( result, regexp ) ->\n    return false if not @isRegexo(regexp)\n    regexp = @toRegexp( regexp )\n    regexp.test(result)\n\n  isCard:( card ) ->\n    @isStr(card) and ( @isType(card,\"int\") or card.includes(\":\") or @isIn(card,\"cards\") )\n\n  # ... more to come for checking cardinallity\n  inCard:( result, spec ) ->\n    card = spec.card\n    switch\n      when @isType(card,\"int\")     then true\n      when @isStr(card) and card.includes(\":\")\n        minMax = @toMinMax(card)\n        num = minMax[0] # Dummy number\n        minMax[0] <= num <= minMax[1]\n      else switch card\n        when \"1\" then true\n        when \"?\" then true\n        when \"*\" then true\n        when \"+\" then true\n        else          false\n\n  toMinMax:( card ) ->\n    splits = card.split(\":\")\n    min    = @toInt(splits[0])\n    max    = @toInt(splits[1])\n    [min,max]\n\n  # Override Type.isIn() with addional Spec type arrays\n  isIn:( type, arg ) ->\n    switch\n     when @isArray(arg) then @inArray( type, arg )\n     when @isEnums(arg) then @inArray( type, @toEnums(arg) )\n     when @isStr(arg)   then @toIn(arg).includes(type)\n     else @isWarn( false, \"arg #{arg} not 'array', 'enums' or 'string'\", type, false )\n\n  # Override Type.isIn() with addional Spec type arrays\n  toIn:( arg ) ->\n    switch\n      when  not  arg? then []\n      when Type[arg]? then Type[arg]\n      when Spec[arg]? then Spec[arg]\n      else []\n\nSpec.matches = [\"range\",\"enums\",\"regexp\"]           # high level matches\nSpec.opers   = [\"to\",\"eq\",\"le\",\"lt\",\"ge\",\"gt\",\"ne\"] # low  level value  based comparison  ooers 'eq' default\nSpec.cards   = [\"1\",\"?\",\"*\",\"+\"]  # cards  1 required, ? optional, * 0 to many, + 1 to many\n\nexport spec = new Spec() # Export a singleton instence of type\nexport default Spec"
  ]
}